# -*- coding: utf-8 -*-
"""Python_sets.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uoZXoDG-TRQ1AjsaESWrV35uphA--Ljr

- `1. Python sets are represented with -> {}`
- `2. Python sets are unordered Pairs -> which means there will be no index concept -> slicing -> skipping `
- `3. Python sets wont allow duplicate values ... `
- `4. Python sets are mutable -> but they wont allow mutable types inside it `
"""

a = 'data' # save in the Memory
print(a) # calling from the Memory

a = [10,20,30,40]
print(a)

a = (10,20,30,40)
print(a)

a = {10,20,30,40}
print(a)

a = {10,100,200,3,4,7,9} # save in the Memory

print(a) # calling from the Memory

a = {10,100,200,3,4,7,9} # save in the Memory

print(a[1]) # calling from the Memory

# duplicate values
a = {10,20,30,50,10,100,20,10} # save in the Memory
print(a)

# point_4

a = {10 , 55.55 , 'data' , (1,2,3)} # save in the Memory
print(a)

# point_4

a = {10 , 55.55 , 'data' , [1,2,3]} # save in the Memory
print(a)

"""**Python_set_built_in_functions**

**addition**
- `add`
- `update `

**deleting**
- `pop`
- `discard`
- `remove`

**common work**
- `clear`
- `copy`
- `union`
- `intersection `
"""

# add -> will take only 1 input from the user -> and will to the existing set randomly

a = {10,5,6,20,98,45} # save in the Memory
print(f'Before adding : {a}')

a.add(600) # adding 600 to the exising set

print(f'After adding : {a}')

# update -> it will take multiple values from the user and will add to the existing list randomlly

a = {10,5,6,20,98,45} # save in the Memory
print(f'Before adding : {a}')

a.update([100,200,300]) # 3 values will be added randomly


print(f'After adding : {a}')

# pop -> will remove one value randomly

a = {10,5,6,20,98,45} # save in the Memory
print(f'Before deleting : {a}')

a.pop() # remove one random value

print(f'After deleting : {a}')

# pop -> will remove one value randomly

a = {10,5,6,20,98,45} # save in the Memory
print(f'Before deleting : {a}')

a.pop(2) # remove one random value

print(f'After deleting : {a}')

# discard -> will take only one input from the user and if the input is available it will remove or else it will be silent

a = {10,5,6,20,98,45} # save in the Memory
print(f'Before deleting : {a}')

a.discard(98) # value will be removed

print(f'After deleting : {a}')

# discard -> will take only one input from the user and if the input is available it will remove or else it will be silent

a = {10,5,6,20,98,45} # save in the Memory
print(f'Before deleting : {a}')

a.discard(980) # thi line will be silent

print(f'After deleting : {a}')

# remove -> will take only one input from the user and if the input is available it will remove or else it will Through Error

a = {10,5,6,20,98,45} # save in the Memory
print(f'Before deleting : {a}')

a.remove(98) # value will be removed

print(f'After deleting : {a}')

# remove -> will take only one input from the user and if the input is available it will remove or else it will Through Error

a = {10,5,6,20,98,45} # save in the Memory
print(f'Before deleting : {a}')

a.remove(980) # it will through Error

print(f'After deleting : {a}')

"""**From the Above Operations we can say that Python sets are Mutable data types**"""

# copy ->
# Deep Copy and Shallow Copy

# Deep copy

a = {10,5,6,20,98,45} # save in the Memory

b = a

print(a)
print(b)

print(id(a))
print(id(b))

# Shallow copy

a = {10,5,6,20,98,45} # save in the Memory

b = a.copy()

print(a)
print(b)

print(id(a))
print(id(b))

# union

a = {1,2,3,4,5,6}
b = {5,6,7,8,9,10}

print(a.union(b))

# intersection

a = {1,2,3,4,5,6}
b = {5,6,7,8,9,10}

print(a.intersection(b))

a = ''
print(type(a))

a = []
print(type(a))

a = ()
print(type(a))

a = {}
print(type(a))

a = {1,10,15,19,25} # save in memory

a.clear()

print(a)

